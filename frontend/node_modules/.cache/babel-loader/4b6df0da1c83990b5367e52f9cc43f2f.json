{"ast":null,"code":"import _get from \"/home/nigel/my-website/node_modules/@babel/runtime/helpers/esm/get\";\nimport _classCallCheck from \"/home/nigel/my-website/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/nigel/my-website/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/nigel/my-website/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/nigel/my-website/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/nigel/my-website/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/home/nigel/my-website/src/components/games/fish_game_files/FishGameContainer.js\";\nimport React, { Component } from 'react';\nimport Col from 'react-bootstrap/Col';\nimport Row from 'react-bootstrap/Row';\n\nvar FishGameContainer =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(FishGameContainer, _Component);\n\n  function FishGameContainer() {\n    _classCallCheck(this, FishGameContainer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FishGameContainer).apply(this, arguments));\n  }\n\n  _createClass(FishGameContainer, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 9\n        },\n        __self: this\n      }, React.createElement(Canvas, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 10\n        },\n        __self: this\n      }));\n    }\n  }]);\n\n  return FishGameContainer;\n}(Component);\n\nexport default FishGameContainer;\nvar gameCanvas = React.createElement(\"canvas\", {\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 18\n  },\n  __self: this\n});\n\nvar Canvas =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Canvas, _React$Component);\n\n  function Canvas() {\n    _classCallCheck(this, Canvas);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Canvas).apply(this, arguments));\n  }\n\n  _createClass(Canvas, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      startGame();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 28\n        },\n        __self: this\n      }, React.createElement(\"canvas\", {\n        id: \"gamecanvas\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 29\n        },\n        __self: this\n      }));\n    }\n  }]);\n\n  return Canvas;\n}(React.Component);\n\nvar myGamePiece;\nvar waterArea;\nvar skyArea;\nvar enemies = new Array();\nvar gameControl;\nvar myPauseButton;\n\nvar gameStateController =\n/*#__PURE__*/\nfunction () {\n  /*things gameStateController will need to keep track of:\n  \t-score\n  \t-is game over\n  \t-is game paused\n  \t-difficulty multiplier, difficulty timer, game timer, enem timer all can be here instead of globals\n  */\n  function gameStateController() {\n    _classCallCheck(this, gameStateController);\n\n    this.diffTimer = 0;\n    this.diffMulti = 0;\n    this.gameTimer = 0;\n    this.enemTimer = 0;\n    this.score = 0;\n    this.isPaused = false;\n    this.isGameOver = false;\n    this.deathString = \"\";\n    this.highScore = 0;\n  }\n\n  _createClass(gameStateController, [{\n    key: \"updateScore\",\n    value: function updateScore() {\n      var ctx = myGameArea.context;\n      ctx.font = \"30px Arial\";\n      ctx.textAlign = \"left\";\n\n      if (!this.isGameOver) {\n        if (this.score <= this.highScore) ctx.fillStyle = \"green\";else ctx.fillStyle = \"yellow\";\n        ctx.fillText(\"Score: \" + this.score, 10, 50);\n      } else {\n        ctx.fillStyle = \"red\";\n        ctx.fillText(\"You Scored: \" + this.score, 10, 50);\n        ctx.textAlign = \"right\";\n        ctx.fillText(\"Press [R] to Restart!\", 790, 50);\n        gameOverText(this.deathString);\n      }\n    }\n  }]);\n\n  return gameStateController;\n}();\n\nfunction startGame() {\n  gameControl = new gameStateController(); //updateLocalStorage(0);\n  //only initialize game area if it has not been initialized before\n\n  console.log(myGameArea);\n  if (!myGameArea.canvas.innerHTML) myGameArea.start();\n  waterArea = new component(800, 550, \"lightblue\", 0, 100);\n  skyArea = new component(800, 100, \"#E6CAAD\", 0, 0);\n  myGamePiece = new player(32, 32, [\"fish1.png\", \"fish2.png\"], 400, 275, \"image\", true); //spawns a boat from either side when starting\n\n  generateEnemy();\n  generateEnemy();\n  if (enemies[0].isRight == enemies[1].isRight) enemies[0].isRight = !enemies[1].isRight;\n  myPauseButton = new pauseButton(740, 10, 50, 50); //with(new AudioContext)[5,7,13].map((v,i)=>{with(createOscillator())v&&start(e=[3,3,3][i]/5,connect(destination),frequency.value=988/1.06**v,type='sawtooth',)+stop(e+.2)});\n}\n\nfunction restartGame() {\n  myGameArea.clear();\n  enemies = new Array();\n  myGamePiece = null;\n  startGame();\n}\n\nvar myGameArea = {\n  canvas: gameCanvas,\n  start: function start() {\n    this.canvas.width = 800;\n    this.canvas.height = 600;\n    this.canvas.innerHTML = \"Your Browser does not support HTML5 canvas!\";\n    this.context = this.canvas.getContext(\"2d\");\n    var insertPoint = document.getElementById(\"gameColumn\");\n    insertPoint.appendChild(this.canvas); //for 60 fps\n\n    this.interval = setInterval(updateGameArea, 16.6666666667);\n    window.addEventListener('keydown', function (e) {\n      myGameArea.keys = myGameArea.keys || [];\n      myGameArea.keys[e.keyCode] = e.type == \"keydown\";\n    });\n    window.addEventListener('keyup', function (e) {\n      myGameArea.keys[e.keyCode] = e.type == \"keydown\";\n    });\n    this.canvas.addEventListener('click', function (evt) {\n      var mousePos = getMousePos(this.canvas, evt);\n\n      if (isInside(mousePos, myPauseButton) && !gameControl.isGameOver) {\n        gameControl.isPaused = !gameControl.isPaused;\n      }\n    }, false);\n  },\n  clear: function clear() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n};\n\nfunction updateGameArea() {\n  myGameArea.clear();\n  myGamePiece.speedX = 0;\n  myGamePiece.speedY = 0;\n\n  if (myGameArea.keys && (myGameArea.keys[37] || myGameArea.keys[65])) {\n    myGamePiece.speedX = -5;\n    if (!gameControl.isPaused) myGamePiece.isRight = false;\n  }\n\n  if (myGameArea.keys && (myGameArea.keys[39] || myGameArea.keys[68])) {\n    myGamePiece.speedX = 5;\n    if (!gameControl.isPaused) myGamePiece.isRight = true;\n  }\n\n  if (myGameArea.keys && (myGameArea.keys[38] || myGameArea.keys[87])) {\n    myGamePiece.speedY = -5;\n  }\n\n  if (myGameArea.keys && (myGameArea.keys[40] || myGameArea.keys[83])) {\n    myGamePiece.speedY = 5;\n  }\n\n  if (myGameArea.keys && myGameArea.keys[32]) {\n    if (myGamePiece.boostCd) {\n      myGamePiece.boostCd--;\n    } else if (myGamePiece.totalBoosts && (myGamePiece.speedX != 0 || myGamePiece.speedY != 0) && !myGamePiece.isBoosting) {\n      myGamePiece.boost();\n    }\n  }\n\n  if (myGameArea.keys && myGameArea.keys[82]) {\n    if (gameControl.isGameOver) {\n      restartGame();\n    }\n  } //get water area\n\n\n  waterArea.update(); //get sky area\n\n  skyArea.update(); //get pause button\n\n  if (!gameControl.isGameOver) myPauseButton.update(); //get enemies\n\n  for (var i = 0; i < enemies.length; i++) {\n    if (gameControl.isGameOver && !enemies.isEnding) enemies[i].endAnimation();\n    enemies[i].newPos();\n    enemies[i].update();\n  } //get player\n\n\n  myGamePiece.newPos();\n  myGamePiece.update();\n  gameControl.updateScore(); //check for collision with player, hooks and bait\n\n  if (!gameControl.isGameOver) {\n    var j = 0;\n\n    for (var i = 0; i < enemies.length; i++) {\n      if (myGamePiece.checkCollision(enemies[i])) {\n        //bonkSfx();\n        gameControl.deathString = \"BONKED!\";\n        gameControl.isPaused = true;\n        gameControl.isGameOver = true;\n        enemies[i].hasFish = true; //updateLocalStorage(gameControl.score);\n\n        break;\n      }\n\n      for (j = 0; j < enemies[i].linesArray.length; j++) {\n        if (myGamePiece.checkCollision(enemies[i].linesArray[j].hook)) {\n          //pause + gameover if player hits hook\n          //hookSfx();\n          gameControl.deathString = \"HOOKED!\";\n          gameControl.isPaused = true;\n          gameControl.isGameOver = true;\n          enemies[i].hasFish = true; //updateLocalStorage(gameControl.score);\n\n          enemies[i].linesArray[j].isReeling = true;\n          myGamePiece.hookAttached = enemies[i].linesArray[j].hook;\n        }\n\n        if (enemies[i].linesArray[j].hasBait) {\n          if (myGamePiece.checkCollision(enemies[i].linesArray[j].lineBait)) {\n            //eatSfx();\n            gameControl.score += 5;\n            enemies[i].linesArray[j].hasBait = false;\n            delete enemies[i].linesArray[j].lineBait; //limits three boosts\n\n            if (myGamePiece.totalBoosts < 3) myGamePiece.totalBoosts++; //add to hunger timer\n\n            myGamePiece.hungerTimer += 240;\n          }\n        }\n      }\n    }\n  }\n\n  var tempEnem; //checks if enemies are off screen, deletes if they are\n\n  for (var i = 0; i < enemies.length; i++) {\n    tempEnem = enemies[i];\n\n    if (tempEnem.isOffScreen()) {\n      enemies.splice(i, 1);\n      tempEnem = null;\n      i--;\n    }\n  } //increments game times (if game is not paused)\n\n\n  if (!gameControl.isPaused) {\n    gameControl.gameTimer++;\n    gameControl.diffTimer++;\n    gameControl.enemTimer++;\n    if (gameControl.gameTimer % 60 == 0) gameControl.score++;\n    myGamePiece.hungerTimer--;\n\n    if (myGamePiece.hungerTimer < 0) {\n      //starveSfx();\n      gameControl.deathString = \"STARVED!\";\n      gameControl.isPaused = true;\n      gameControl.isGameOver = true; //updateLocalStorage(gameControl.score);\n\n      myGamePiece.starve();\n    }\n  } //spawns enemy based on difficulty\n\n\n  if (gameControl.enemTimer >= 60 * 10 - 60 * (gameControl.diffMulti - 1)) {\n    if (gameControl.diffMulti < 1) {\n      generateEnemy();\n      gameControl.enemTimer = 0;\n    } else if (gameControl.diffMulti < 6) {\n      generateEnemy();\n      generateEnemy();\n      gameControl.enemTimer = 0;\n    } else {\n      generateEnemy();\n      generateEnemy();\n      generateEnemy();\n      gameControl.enemTimer = 0;\n    }\n  } //increase difficulty every 5 seconds\n\n\n  if (gameControl.diffTimer >= 60 * 7) {\n    if (gameControl.diffMulti != 9) gameControl.diffMulti++;\n    gameControl.diffTimer = 0;\n  }\n}\n\nvar component =\n/*#__PURE__*/\nfunction () {\n  function component(width, height, images, x, y, type, isRight) {\n    _classCallCheck(this, component);\n\n    this.type = type;\n\n    if (this.type == \"image\") {\n      this.images = images;\n      this.image = new Image();\n      this.image.src = images[0];\n    } else {\n      this.images = images;\n    }\n\n    this.gamearea = myGameArea;\n    this.width = width;\n    this.height = height;\n    this.speedX = 0;\n    this.speedY = 0;\n    this.x = x;\n    this.y = y;\n    this.isRight = isRight;\n    this.shouldFlipY = false;\n  }\n\n  _createClass(component, [{\n    key: \"update\",\n    value: function update() {\n      var ctx = myGameArea.context;\n\n      if (this.type == \"image\") {\n        if (!this.isRight) {\n          if (this.shouldFlipY) {\n            ctx.save();\n            ctx.scale(-1, -1);\n            ctx.drawImage(this.image, -this.x - this.width, -this.y - this.height);\n            ctx.restore();\n          } else {\n            ctx.save();\n            ctx.scale(-1, 1);\n            ctx.drawImage(this.image, -this.x - this.width, this.y, this.width, this.height);\n            ctx.restore();\n          }\n        } else {\n          if (this.shouldFlipY) {\n            ctx.save();\n            ctx.scale(1, -1);\n            ctx.drawImage(this.image, this.x, -this.y - this.height);\n            ctx.restore();\n          } else {\n            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);\n          }\n        }\n      } //fill in rect if no image passed\n      else {\n          ctx.fillStyle = this.images;\n          ctx.fillRect(this.x, this.y, this.width, this.height);\n        }\n    }\n  }, {\n    key: \"checkCollision\",\n    value: function checkCollision(otherComponent) {\n      //checks if this component is within another\n      if (this.x < otherComponent.x + otherComponent.width && this.x + this.width > otherComponent.x && this.y < otherComponent.y + otherComponent.height && this.y + this.height > otherComponent.y) {\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return component;\n}();\n\nvar player =\n/*#__PURE__*/\nfunction (_component) {\n  _inherits(player, _component);\n\n  function player(width, height, images, x, y, type, isRight) {\n    var _this;\n\n    _classCallCheck(this, player);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(player).call(this, width, height, images, x, y, type, isRight));\n    _this.playerAnimCount = 0;\n    _this.curPlayerAnimIndex = 0;\n    _this.hookAttached = null; //boost related variables to keep track of\n\n    _this.totalBoosts = 3;\n    _this.isBoosting = false;\n    _this.boostLocation = new Array(0, 0);\n    _this.boostLength = 100; //length of boost in pixels\n\n    _this.boostDuration = 5; //duration of boost in frames\n\n    _this.boostCd = 0;\n    _this.hungerTimer = 1800; //1800 = 30sec\n\n    return _this;\n  }\n\n  _createClass(player, [{\n    key: \"updateAnim\",\n    value: function updateAnim() {\n      if (this.playerAnimCount > 10) {\n        if (this.curPlayerAnimIndex == this.images.length - 1) {\n          this.image.src = this.images[0];\n          this.curPlayerAnimIndex = 0;\n        } else {\n          this.curPlayerAnimIndex++;\n          this.image.src = this.images[this.curPlayerAnimIndex];\n        }\n\n        this.playerAnimCount = 0;\n      }\n    }\n  }, {\n    key: \"newPos\",\n    value: function newPos() {\n      if (!gameControl.isPaused) {\n        var borderCollisionX = false;\n        var borderCollisionY = false; //these variables will hold the speed of x that we are adding to player (depends on whether player is boosting or not)\n\n        var tempSpeedX;\n        var tempSpeedY;\n\n        if (this.isBoosting) {\n          if (this.x != this.boostLocation[0]) {\n            if (this.x <= this.boostLocation[0]) tempSpeedX = this.boostLength / this.boostDuration;else tempSpeedX = this.boostLength / this.boostDuration * -1;\n          } else {\n            tempSpeedX = 0;\n          }\n\n          if (this.y != this.boostLocation[1]) {\n            if (this.y <= this.boostLocation[1]) tempSpeedY = this.boostLength / this.boostDuration;else tempSpeedY = this.boostLength / this.boostDuration * -1;\n          } else {\n            tempSpeedY = 0;\n          }\n        } else {\n          tempSpeedX = this.speedX;\n          tempSpeedY = this.speedY;\n        }\n\n        if (this.x + tempSpeedX > myGameArea.canvas.width - this.width) {\n          this.x = myGameArea.canvas.width - this.width;\n          borderCollisionX = true;\n        }\n\n        if (this.x + tempSpeedX < 0) {\n          this.x = 0;\n          borderCollisionX = true;\n        }\n\n        if (this.y + tempSpeedY > myGameArea.canvas.height - this.height) {\n          this.y = myGameArea.canvas.height - this.height;\n          borderCollisionY = true;\n        }\n\n        if (this.y + tempSpeedY < 100) {\n          this.y = 100;\n          borderCollisionY = true;\n        }\n\n        if (!borderCollisionX) {\n          this.x += tempSpeedX;\n        }\n\n        if (!borderCollisionY) {\n          this.y += tempSpeedY; //gravity underwater (only when not boosting)\n\n          if (!this.isBoosting && this.y != myGameArea.canvas.height + this.height) this.y += 0.5;\n        }\n\n        if (this.speedX != 0 || this.speedY != 0) {\n          this.playerAnimCount++;\n        } else {\n          this.playerAnimCount = 0;\n          this.curPlayerAnimIndex = 0;\n          this.image.src = this.images[this.curPlayerAnimIndex];\n        }\n\n        if (this.isBoosting) {\n          if (this.x == this.boostLocation[0] && this.y == this.boostLocation[1]) {\n            this.isBoosting = false; //cooldown for boost - in frames\n\n            this.boostCd = 5;\n          }\n        }\n\n        this.updateAnim();\n      }\n\n      if (gameControl.isGameOver) {\n        //lost because of hook\n        if (this.hookAttached) {\n          this.loseAnimationHook();\n        } //lost because of hunger timer\n        else if (this.hungerTimer <= 0) {\n            if (this.y >= waterArea.y - 16) this.y -= 3;\n          } //lost because of collision with enemy boat\n          else {\n              if (this.y >= waterArea.y - 32) this.y--;\n            }\n      }\n    }\n  }, {\n    key: \"loseAnimationHook\",\n    value: function loseAnimationHook() {\n      //later I will make fish turn to face angle of line, for now I do not need this\n      this.x = this.hookAttached.x;\n      this.y = this.hookAttached.y;\n    }\n  }, {\n    key: \"boost\",\n    value: function boost() {\n      if (this.speedX > 0) {\n        this.boostLocation[0] = this.x + this.boostLength;\n\n        if (this.boostLocation[0] > myGameArea.canvas.width - this.width) {\n          this.boostLocation[0] = myGameArea.canvas.width - this.width;\n        }\n      } else if (this.speedX < 0) {\n        this.boostLocation[0] = this.x - this.boostLength;\n\n        if (this.boostLocation[0] < 0) {\n          this.boostLocation[0] = 0;\n        }\n      } else {\n        this.boostLocation[0] = this.x;\n      }\n\n      if (this.speedY > 0) {\n        this.boostLocation[1] = this.y + this.boostLength;\n\n        if (this.boostLocation[1] > myGameArea.canvas.height - this.height) {\n          this.boostLocation[1] = myGameArea.canvas.height - this.height;\n        }\n      } else if (this.speedY < 0) {\n        this.boostLocation[1] = this.y - this.boostLength;\n\n        if (this.boostLocation[1] < 100) {\n          this.boostLocation[1] = 100;\n        }\n      } else {\n        this.boostLocation[1] = this.y;\n      } //prevents player from getting stuck in the bottom\n\n\n      if (this.boostLocation[1] + this.height > myGameArea.canvas.height - this.height) this.boostLocation[1] = myGameArea.canvas.height - this.height;\n      if (!gameControl.isGameOver) //boostSfx();\n        this.totalBoosts--;\n      this.isBoosting = true;\n    }\n  }, {\n    key: \"drawBoostCircles\",\n    value: function drawBoostCircles(ctx) {\n      var tempX;\n      var tempY;\n\n      for (var i = 1; i <= 3; i++) {\n        tempX = this.x + this.width / 2 * (i - 1);\n        tempY = this.y - 8;\n        ctx.beginPath();\n        ctx.arc(tempX, tempY, 6, 0, 2 * Math.PI, false); //full circle - if there is a boost, fill the circle\n\n        if (i <= this.totalBoosts) {\n          ctx.fillStyle = 'pink';\n          ctx.fill();\n        } //empty circle - no boost\n\n\n        ctx.strokeStyle = 'hotpink';\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: \"starve\",\n    value: function starve() {\n      this.shouldFlipY = true;\n    }\n  }, {\n    key: \"drawHungerTimer\",\n    value: function drawHungerTimer(ctx) {\n      ctx.font = \"30px Comic Sans MS\";\n      if (this.hungerTimer > 300) ctx.fillStyle = \"hotpink\";else ctx.fillStyle = \"red\";\n      ctx.textAlign = \"center\";\n      if (!this.isGameOver) ctx.fillText(\"\" + Math.round(this.hungerTimer / 60), this.x + this.width / 2, this.y - 16);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (!gameControl.isGameOver) {\n        this.drawHungerTimer(myGameArea.context);\n        this.drawBoostCircles(myGameArea.context);\n      }\n\n      _get(_getPrototypeOf(player.prototype), \"update\", this).call(this);\n    }\n  }]);\n\n  return player;\n}(component);\n\nfunction generateEnemy() {\n  var newWidth = randomIntFromInterval(32, 128);\n  var newHeight = 32;\n  var spawnLoc = Math.floor(Math.random() * 2 + 1);\n  var newY;\n  var newX;\n  var newIsRight;\n\n  if (spawnLoc == 1) {\n    newY = 100 - newHeight / 2;\n    newX = 0 - newWidth;\n    newIsRight = true;\n  } else {\n    newY = 100 - newHeight / 2;\n    newX = myGameArea.canvas.width;\n    newIsRight = false;\n  } //randomly generate speed later\n\n\n  if (gameControl.diffMulti < 5) var newSpeed = randomIntFromInterval(1, 3);else var newSpeed = randomIntFromInterval(2, 6);\n  var newNumPoles;\n  if (gameControl.diffMulti == 1) newNumPoles = 1;else if (gameControl.diffMulti < 4) {\n    newNumPoles = randomIntFromInterval(1, 2);\n  } else if (gameControl.diffMulti < 7) {\n    newNumPoles = randomIntFromInterval(1, 3);\n  } else {\n    newNumPoles = randomIntFromInterval(1, 4);\n  }\n  enemies.push(new enemy(newWidth, newHeight, [\"boat.png\"], newX, newY, \"image\", newIsRight, newSpeed, newNumPoles));\n} //enemy class\n\n\nvar enemy =\n/*#__PURE__*/\nfunction (_component2) {\n  _inherits(enemy, _component2);\n\n  //movement function (bobs up and down and moves across)\n  //new constructor that specifies speed\n  //array of lines\n  //pole draw function (hard)\n  //number of poles\n  function enemy(width, height, images, x, y, type, isRight, speed, numPoles) {\n    var _this2;\n\n    _classCallCheck(this, enemy);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(enemy).call(this, width, height, images, x, y, type, isRight));\n    _this2.speedX = speed;\n    _this2.numPoles = numPoles;\n    _this2.linesArray = new Array();\n    _this2.startingPositions = new Array();\n\n    _this2.getStartingPositions();\n\n    _this2.generateLines();\n\n    _this2.hasFish = false;\n    _this2.isEnding = false;\n    return _this2;\n  }\n\n  _createClass(enemy, [{\n    key: \"newPos\",\n    value: function newPos() {\n      if (!gameControl.isPaused || gameControl.isGameOver && !this.hasFish) {\n        //need to add bobbing up and down here\n        if (this.isRight) {\n          this.x += this.speedX;\n\n          for (var i = 0; i < this.startingPositions.length; i++) {\n            this.startingPositions[i] += this.speedX;\n          }\n        } else {\n          this.x -= this.speedX;\n\n          for (var i = 0; i < this.startingPositions.length; i++) {\n            this.startingPositions[i] -= this.speedX;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"endAnimation\",\n    value: function endAnimation() {\n      if (!this.isEnding) {\n        if (!this.hasFish) {\n          this.isEnding = true;\n\n          if (this.x + this.width > myGameArea.canvas.width / 2) {\n            this.isRight = true;\n          } else {\n            this.isRight = false;\n          }\n\n          for (var i = 0; i < this.linesArray.length; i++) {\n            this.linesArray[i].speed *= 3;\n\n            if (this.linesArray[i].isRight == this.isRight) {\n              this.linesArray[i].hook.isRight = this.isRight;\n              if (this.linesArray[i].hasBait) this.linesArray[i].lineBait.isRight = this.isRight;\n            } else {\n              this.linesArray[i].isRight = this.isRight; //this means that it will be turning right\n\n              if (this.isRight) {\n                this.linesArray[i].startPos[0] -= 30;\n                this.linesArray[i].endPos[0] -= 30;\n                this.linesArray[i].hook.x -= 30;\n                if (this.linesArray[i].hasBait) this.linesArray[i].baitPoint[0] -= 30;\n              } else {\n                this.linesArray[i].startPos[0] += 30;\n                this.linesArray[i].endPos[0] += 30;\n                this.linesArray[i].hook.x += 30;\n                if (this.linesArray[i].hasBait) this.linesArray[i].baitPoint[0] += 30;\n              }\n\n              this.linesArray[i].hook.isRight = this.isRight;\n              if (this.linesArray[i].hasBait) this.linesArray[i].lineBait.isRight = this.isRight;\n            }\n          }\n        } else {\n          this.isEnding = true;\n        }\n\n        this.speedX *= 3;\n      }\n    } //gets starting positions of the lines\n\n  }, {\n    key: \"getStartingPositions\",\n    value: function getStartingPositions() {\n      //draw each pole, starting from the left\n      var tempPos = this.x;\n\n      for (var i = 0; i < this.numPoles; i++) {\n        tempPos = tempPos + this.width / (this.numPoles + 1);\n        this.startingPositions.push(tempPos);\n      }\n    } //generates lines that are coming off of the boat\n\n  }, {\n    key: \"generateLines\",\n    value: function generateLines() {\n      var newAngle;\n      var newLength;\n      var newHasBait;\n      var startPos;\n\n      for (var i = 0; i < this.startingPositions.length; i++) {\n        //calculates an angle between 45 and 90 degs\t\n        newLength = randomIntFromInterval(75, 510);\n        if (gameControl.diffMulti == 1) newHasBait = 1;else if (gameControl.diffMulti < 4) newHasBait = randomIntFromInterval(1, 2);else if (gameControl.diffMulti < 7) newHasBait = randomIntFromInterval(1, 3);else newHasBait = randomIntFromInterval(1, 5);\n        if (newHasBait == 1) newHasBait = true;else newHasBait = false;\n\n        if (!this.isRight) {\n          startPos = [this.startingPositions[i] + 15, this.y - 15];\n          newAngle = randomIntFromInterval(45, 90);\n        } else {\n          startPos = [this.startingPositions[i] - 15, this.y - 15];\n          newAngle = randomIntFromInterval(90, 135);\n        }\n\n        this.linesArray.push(new line(newAngle, startPos, newLength, this.speedX, this.isRight, newHasBait, this));\n      }\n    }\n  }, {\n    key: \"drawPoles\",\n    value: function drawPoles() {\n      var ctx = myGameArea.context;\n\n      for (var i = 0; i < this.startingPositions.length; i++) {\n        ctx.beginPath();\n        ctx.moveTo(this.startingPositions[i], this.y);\n        ctx.lineTo(this.startingPositions[i], this.y - 15);\n\n        if (!this.isRight) {\n          ctx.lineTo(this.startingPositions[i] + 15, this.y - 15);\n        } else {\n          ctx.lineTo(this.startingPositions[i] - 15, this.y - 15);\n        }\n\n        ctx.strokeStyle = 'black';\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: \"drawLines\",\n    value: function drawLines() {\n      for (var i = 0; i < this.linesArray.length; i++) {\n        this.linesArray[i].newPos();\n        this.linesArray[i].update();\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      _get(_getPrototypeOf(enemy.prototype), \"update\", this).call(this);\n\n      this.drawPoles();\n      this.drawLines();\n    }\n  }, {\n    key: \"isOffScreen\",\n    value: function isOffScreen() {\n      var tempHook;\n      var boatOffScreen = false;\n\n      if (this.isRight) {\n        if (this.x > myGameArea.canvas.width) {\n          boatOffScreen = true;\n        }\n      } else {\n        if (this.x + this.width < 0) {\n          boatOffScreen = true;\n        }\n      } //if the boat is not off the screen, there is no reason to delete it\n\n\n      if (!boatOffScreen) {\n        return false;\n      }\n\n      var numHooksOff = 0;\n\n      for (var i = 0; i < this.linesArray.length; i++) {\n        tempHook = this.linesArray[i].hook;\n\n        if (this.isRight) {\n          if (tempHook.x > myGameArea.canvas.width) {\n            numHooksOff++;\n          }\n        } else {\n          if (tempHook.x + tempHook.width < 0) {\n            numHooksOff++;\n          }\n        }\n      } //returns true if all hooks are off the screen\n\n\n      if (numHooksOff == this.linesArray.length) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return enemy;\n}(component); //line class, not a component because not a rectangle\n\n\nvar line =\n/*#__PURE__*/\nfunction () {\n  function line(angle, startPos, length, speed, isRight, hasBait, parentBoat) {\n    _classCallCheck(this, line);\n\n    this.angle = angle;\n    this.startPos = startPos;\n    this.length = length;\n    this.speed = speed;\n    this.isRight = isRight;\n    this.parentBoat = parentBoat;\n    this.endPos = new Array();\n    this.calculateEndPos();\n    this.hasBait = hasBait;\n\n    if (hasBait) {\n      this.baitPoint = new Array();\n      this.generateBaitPoint();\n      this.lineBait = new bait(this.baitPoint[0], this.baitPoint[1], this);\n    }\n\n    var xPos;\n    var yPos;\n\n    if (this.isRight) {\n      xPos = this.endPos[0] + 12;\n    } else {\n      xPos = this.endPos[0] - 12;\n    }\n\n    this.hook = new hook(24, 24, [\"hook.png\"], xPos, this.endPos[1], \"image\", this.isRight, this.speed, this);\n    this.isReeling = false;\n  } //hitting a line will slow the player down (unless obtaining bait)\n\n\n  _createClass(line, [{\n    key: \"collisionCheck\",\n    value: function collisionCheck() {} //move the start position of the line before next update\n\n  }, {\n    key: \"newPos\",\n    value: function newPos() {\n      if (!gameControl.isPaused || gameControl.isGameOver && !this.parentBoat.hasFish) {\n        if (this.isRight) {\n          this.startPos[0] += this.speed;\n          this.endPos[0] += this.speed;\n          if (this.hasBait) this.baitPoint[0] += this.speed;\n        } else {\n          this.startPos[0] -= this.speed;\n          this.endPos[0] -= this.speed;\n          if (this.hasBait) this.baitPoint[0] -= this.speed;\n        }\n      }\n\n      if (this.isReeling) {\n        if (this.hasBait) {\n          this.hasBait = false;\n          delete this.lineBait;\n        }\n\n        if (this.length >= 0) {\n          this.length -= 3;\n          this.calculateEndPos();\n        } else {\n          this.length = 0;\n          this.isReeling = false;\n        }\n      }\n\n      this.hook.newPos();\n      if (this.hasBait) this.lineBait.newPos();\n    }\n  }, {\n    key: \"calculateEndPos\",\n    value: function calculateEndPos() {\n      this.endPos[0] = this.startPos[0] + this.length * Math.cos(Math.PI * this.angle / 180);\n      this.endPos[1] = this.startPos[1] + this.length * Math.sin(Math.PI * this.angle / 180);\n    } //draw line\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      //draw the line\n      var ctx = myGameArea.context;\n      ctx.beginPath();\n      ctx.moveTo(this.startPos[0], this.startPos[1]);\n      ctx.lineTo(this.endPos[0], this.endPos[1]);\n      ctx.strokeStyle = 'black';\n      ctx.stroke(); //draw the hook\n\n      this.hook.update();\n      if (this.hasBait) this.lineBait.update();\n    } //moveline - later when I add up and down movement to line\n\n  }, {\n    key: \"moveLine\",\n    value: function moveLine() {} //will be used to generate a point to put the bait on the line\n\n  }, {\n    key: \"generateBaitPoint\",\n    value: function generateBaitPoint() {\n      //bait will be randomly placed from halfway down the line to the end\n      var baitLength = randomIntFromInterval(this.length / 2, this.length - 10); //get x position of bait\n\n      this.baitPoint[0] = this.startPos[0] + baitLength * Math.cos(Math.PI * this.angle / 180); //get y position of bait\n\n      this.baitPoint[1] = this.startPos[1] + baitLength * Math.sin(Math.PI * this.angle / 180);\n    }\n  }]);\n\n  return line;\n}(); //bait class, feeds player, gives boost, and increases score by 5\n\n\nvar bait =\n/*#__PURE__*/\nfunction (_component3) {\n  _inherits(bait, _component3);\n\n  function bait(x, y, parentLine) {\n    var _this3;\n\n    _classCallCheck(this, bait);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(bait).call(this, 24, 24, [\"bait1.png\", \"bait2.png\"], x, y, \"image\", parentLine.isRight));\n    _this3.parentLine = parentLine;\n    _this3.animCount = 0;\n    _this3.curAnimIndex = 0;\n    _this3.animLength = randomIntFromInterval(10, 20);\n    return _this3;\n  }\n\n  _createClass(bait, [{\n    key: \"updateAnim\",\n    value: function updateAnim() {\n      if (this.animCount > this.animLength) {\n        if (this.curAnimIndex == this.images.length - 1) {\n          this.image.src = this.images[0];\n          this.curAnimIndex = 0;\n        } else {\n          this.curAnimIndex++;\n          this.image.src = this.images[this.curAnimIndex];\n        }\n\n        this.animCount = 0;\n      }\n    }\n  }, {\n    key: \"newPos\",\n    value: function newPos() {\n      this.x = this.parentLine.baitPoint[0] - 12;\n      this.y = this.parentLine.baitPoint[1];\n\n      if (!gameControl.isPaused || gameControl.isGameOver && !this.parentLine.parentBoat.hasFish) {\n        this.animCount++;\n        this.updateAnim();\n      }\n    }\n  }]);\n\n  return bait;\n}(component); //hook class\n\n\nvar hook =\n/*#__PURE__*/\nfunction (_component4) {\n  _inherits(hook, _component4);\n\n  function hook(width, height, images, x, y, type, isRight, speed, parentLine) {\n    var _this4;\n\n    _classCallCheck(this, hook);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(hook).call(this, width, height, images, x, y, type, isRight));\n\n    if (isRight) {\n      _this4.x = _this4.x - _this4.width;\n    }\n\n    _this4.speedX = speed;\n    _this4.parentLine = parentLine;\n    return _this4;\n  } //making it so the hook is always on the end of the line, no matter where it moves to\n\n\n  _createClass(hook, [{\n    key: \"newPos\",\n    value: function newPos() {\n      this.x = this.parentLine.endPos[0] - 12;\n      this.y = this.parentLine.endPos[1];\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      _get(_getPrototypeOf(hook.prototype), \"update\", this).call(this);\n    }\n  }]);\n\n  return hook;\n}(component); //graphic for a pause button\n\n\nvar pauseButton =\n/*#__PURE__*/\nfunction () {\n  function pauseButton(x, y, width, height) {\n    _classCallCheck(this, pauseButton);\n\n    //initially the game will start off playing\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.playing = true;\n  }\n\n  _createClass(pauseButton, [{\n    key: \"update\",\n    value: function update() {\n      if (gameControl.isPaused) this.playing = false;else this.playing = true;\n      var ctx = myGameArea.context;\n      ctx.fillStyle = \"black\"; //draws pause icon\n\n      if (this.playing) {\n        ctx.fillRect(this.x, this.y, this.width / 3, this.height);\n        ctx.fillRect(this.x + 2 * (this.width / 3), this.y, this.width / 3, this.height);\n      } //draws play icon\n      else {\n          ctx.beginPath();\n          ctx.moveTo(this.x, this.y);\n          ctx.lineTo(this.x, this.y + this.height);\n          ctx.lineTo(this.x + this.width, this.y + this.height / 2);\n          ctx.fill();\n        }\n    }\n  }]);\n\n  return pauseButton;\n}(); //HELPER FUNCTIONS BELOW\n\n\nfunction randomIntFromInterval(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n} //mouse detection functions (only used for pause button)\n\n\nfunction getMousePos(canvas, event) {\n  var rect = myGameArea.canvas.getBoundingClientRect();\n  return {\n    x: event.clientX - rect.left,\n    y: event.clientY - rect.top\n  };\n}\n\nfunction isInside(pos, rect) {\n  return pos.x > rect.x && pos.x < rect.x + rect.width && pos.y < rect.y + rect.height && pos.y > rect.y;\n} //displays game over text in middle of screen\n\n\nfunction gameOverText(text) {\n  var ctx = myGameArea.context;\n  ctx.font = \"50px Comic Sans MS\";\n  ctx.fillStyle = \"black\";\n  ctx.textAlign = \"center\";\n  ctx.fillText(\"\" + text, 400, 300);\n} //sound effects - made with miniMusic - https://xem.github.io/miniMusic/simple.html\n\n/*\nfunction boostSfx()\n{\n\twith(new AudioContext)\n\twith(G=createGain())\n\tfor(i in D=[14,9,2])\n\twith(createOscillator())\n\tif(D[i])\n\tconnect(G),\n\tG.connect(destination),\n\tstart(i*.05),\n\tfrequency.setValueAtTime(440*1.06**(13-D[i]),i*.05),type='triangle',\n\tgain.setValueAtTime(1,i*.05),\n\tgain.setTargetAtTime(.0001,i*.05+.03,.005),\n\tstop(i*.05+.04);\n}\n\nfunction eatSfx()\n{\n\twith(new AudioContext)\n\twith(G=createGain())\n\tfor(i in D=[14,12,12,9])\n\twith(createOscillator())\n\tif(D[i])\n\tconnect(G),\n\tG.connect(destination),\n\tstart(i*.075),\n\tfrequency.setValueAtTime(440*1.06**(13-D[i]),i*.075),type='triangle',\n\tgain.setValueAtTime(1,i*.075),\n\tgain.setTargetAtTime(.0001,i*.075+.05,.005),\n\tstop(i*.075+.07);\n}\n\nfunction hookSfx()\n{\n\twith(new AudioContext)\n\twith(G=createGain())\n\tfor(i in D=[18,19,24,25,24])\n\twith(createOscillator())\n\tif(D[i])\n\tconnect(G),\n\tG.connect(destination),\n\tstart(i*.1),\n\tfrequency.setValueAtTime(440*1.06**(13-D[i]),i*.1),type='triangle',\n\tgain.setValueAtTime(1,i*.1),\n\tgain.setTargetAtTime(.0001,i*.1+.08,.005),\n\tstop(i*.1+.09);\n}\n\nfunction bonkSfx()\n{\n\twith(new AudioContext)\n\twith(G=createGain())\n\tfor(i in D=[22,22,23,24,23])\n\twith(createOscillator())\n\tif(D[i])\n\tconnect(G),\n\tG.connect(destination),\n\tstart(i*.022),\n\tfrequency.setValueAtTime(440*1.06**(13-D[i]),i*.022),\n\tgain.setValueAtTime(1,i*.022),\n\tgain.setTargetAtTime(.0001,i*.022+.00,.005),\n\tstop(i*.022+.01);\n}\n\nfunction starveSfx()\n{\n\twith(new AudioContext)\n\twith(G=createGain())\n\tfor(i in D=[21,,24,24,25])\n\twith(createOscillator())\n\tif(D[i])\n\tconnect(G),\n\tG.connect(destination),\n\tstart(i*.22),\n\tfrequency.setValueAtTime(440*1.06**(13-D[i]),i*.22),\n\tgain.setValueAtTime(1,i*.22),\n\tgain.setTargetAtTime(.0001,i*.22+.20,.005),\n\tstop(i*.22+.21)\n}\n*/","map":{"version":3,"sources":["/home/nigel/my-website/src/components/games/fish_game_files/FishGameContainer.js"],"names":["React","Component","Col","Row","FishGameContainer","gameCanvas","Canvas","startGame","myGamePiece","waterArea","skyArea","enemies","Array","gameControl","myPauseButton","gameStateController","diffTimer","diffMulti","gameTimer","enemTimer","score","isPaused","isGameOver","deathString","highScore","ctx","myGameArea","context","font","textAlign","fillStyle","fillText","gameOverText","console","log","canvas","innerHTML","start","component","player","generateEnemy","isRight","pauseButton","restartGame","clear","width","height","getContext","insertPoint","document","getElementById","appendChild","interval","setInterval","updateGameArea","window","addEventListener","e","keys","keyCode","type","evt","mousePos","getMousePos","isInside","clearRect","speedX","speedY","boostCd","totalBoosts","isBoosting","boost","update","i","length","isEnding","endAnimation","newPos","updateScore","j","checkCollision","hasFish","linesArray","hook","isReeling","hookAttached","hasBait","lineBait","hungerTimer","tempEnem","isOffScreen","splice","starve","images","x","y","image","Image","src","gamearea","shouldFlipY","save","scale","drawImage","restore","fillRect","otherComponent","playerAnimCount","curPlayerAnimIndex","boostLocation","boostLength","boostDuration","borderCollisionX","borderCollisionY","tempSpeedX","tempSpeedY","updateAnim","loseAnimationHook","tempX","tempY","beginPath","arc","Math","PI","fill","strokeStyle","stroke","round","drawHungerTimer","drawBoostCircles","newWidth","randomIntFromInterval","newHeight","spawnLoc","floor","random","newY","newX","newIsRight","newSpeed","newNumPoles","push","enemy","speed","numPoles","startingPositions","getStartingPositions","generateLines","startPos","endPos","baitPoint","tempPos","newAngle","newLength","newHasBait","line","moveTo","lineTo","drawPoles","drawLines","tempHook","boatOffScreen","numHooksOff","angle","parentBoat","calculateEndPos","generateBaitPoint","bait","xPos","yPos","cos","sin","baitLength","parentLine","animCount","curAnimIndex","animLength","playing","min","max","event","rect","getBoundingClientRect","clientX","left","clientY","top","pos","text"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Col from 'react-bootstrap/Col';\nimport Row from 'react-bootstrap/Row';\n\nclass FishGameContainer extends Component {\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<Canvas />\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default FishGameContainer;\n\nconst gameCanvas = <canvas />\n\nclass Canvas extends React.Component {\n\n\tcomponentDidMount() {\n\t\tstartGame();\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<canvas id=\"gamecanvas\" />\n\t\t\t</div>\n\t\t)\n\t}\n}\n\n\n\nvar myGamePiece;\nvar waterArea;\nvar skyArea;\nvar enemies = new Array();\nvar gameControl;\nvar myPauseButton;\n\nclass gameStateController\n{\n\t/*things gameStateController will need to keep track of:\n\t\t-score\n\t\t-is game over\n\t\t-is game paused\n\t\t-difficulty multiplier, difficulty timer, game timer, enem timer all can be here instead of globals\n\t*/\n\n\tconstructor()\n\t{\n\t\tthis.diffTimer = 0;\n\t\tthis.diffMulti = 0;\n\t\tthis.gameTimer = 0;\n\t\tthis.enemTimer = 0;\n\t\tthis.score = 0;\n\t\tthis.isPaused = false;\n\t\tthis.isGameOver = false;\n\t\tthis.deathString = \"\";\n\t\tthis.highScore = 0;\n\t}\n\n\tupdateScore()\n\t{\n\t\tvar ctx = myGameArea.context;\n\t\tctx.font = \"30px Arial\";\n\t\t\n\t\tctx.textAlign = \"left\";\n\t\tif(!this.isGameOver)\n\t\t{\n\t\t\tif(this.score <= this.highScore)\n\t\t\t\tctx.fillStyle = \"green\";\n\t\t\telse\n\t\t\t\tctx.fillStyle = \"yellow\";\n\t\t\tctx.fillText(\"Score: \" + this.score, 10, 50);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tctx.fillStyle = \"red\";\n\t\t\tctx.fillText(\"You Scored: \" + this.score, 10, 50);\n\t\t\tctx.textAlign = \"right\";\n\t\t\tctx.fillText(\"Press [R] to Restart!\", 790, 50);\n\t\t\tgameOverText(this.deathString);\n\t\t}\n\t}\n}\n\nfunction startGame() {\n\tgameControl = new gameStateController();\n\t//updateLocalStorage(0);\n\t//only initialize game area if it has not been initialized before\n\tconsole.log(myGameArea);\n\tif(!myGameArea.canvas.innerHTML)\n    \tmyGameArea.start();\n    waterArea = new component(800,550, \"lightblue\", 0, 100);\n    skyArea = new component(800,100, \"#E6CAAD\", 0, 0);\n    myGamePiece = new player(32, 32, [\"fish1.png\",\"fish2.png\"], 400, 275, \"image\", true);\n    //spawns a boat from either side when starting\n    generateEnemy();\n    generateEnemy();\n    if(enemies[0].isRight == enemies[1].isRight)\n    \tenemies[0].isRight = !enemies[1].isRight;\n    myPauseButton = new pauseButton(740, 10, 50, 50);\n    //with(new AudioContext)[5,7,13].map((v,i)=>{with(createOscillator())v&&start(e=[3,3,3][i]/5,connect(destination),frequency.value=988/1.06**v,type='sawtooth',)+stop(e+.2)});\n}\n\nfunction restartGame()\n{\n\tmyGameArea.clear();\n\tenemies = new Array();\n\tmyGamePiece = null;\n\tstartGame();\n\n}\n\nvar myGameArea = {\n    canvas : gameCanvas,\n    start : function() {\n        this.canvas.width = 800;\n        this.canvas.height = 600;\n        this.canvas.innerHTML = \"Your Browser does not support HTML5 canvas!\"\n        this.context = this.canvas.getContext(\"2d\");\n        var insertPoint = document.getElementById(\"gameColumn\");\n        insertPoint.appendChild(this.canvas);\n        //for 60 fps\n        this.interval = setInterval(updateGameArea, 16.6666666667);\n        window.addEventListener('keydown', function (e) {\n            myGameArea.keys = (myGameArea.keys || []);\n            myGameArea.keys[e.keyCode] = (e.type == \"keydown\");\n        })\n        window.addEventListener('keyup', function (e) {\n            myGameArea.keys[e.keyCode] = (e.type == \"keydown\");            \n        })\n        this.canvas.addEventListener('click', function(evt) {\n\t\t\tvar mousePos = getMousePos(this.canvas, evt);\n\t\t\tif (isInside(mousePos,myPauseButton) && !gameControl.isGameOver) {\n\t\t\t\tgameControl.isPaused = !gameControl.isPaused;\n\t\t    }\t\n\t\t}, false);\n    }, \n    clear : function(){\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n}\n\nfunction updateGameArea() {\n    myGameArea.clear();\n    myGamePiece.speedX = 0;\n    myGamePiece.speedY = 0;    \n    \n    if (myGameArea.keys && (myGameArea.keys[37] || myGameArea.keys[65])) {\n    \tmyGamePiece.speedX = -5;\n    \tif(!gameControl.isPaused)\n    \t\tmyGamePiece.isRight = false;\n    }\n    if (myGameArea.keys && (myGameArea.keys[39] || myGameArea.keys[68])) {\n    \tmyGamePiece.speedX = 5; \n    \tif(!gameControl.isPaused)\n    \t\tmyGamePiece.isRight = true;\n    }\n    if (myGameArea.keys && (myGameArea.keys[38] || myGameArea.keys[87])) {\n    \tmyGamePiece.speedY = -5; \n    }\n    if (myGameArea.keys && (myGameArea.keys[40] || myGameArea.keys[83])) {\n    \tmyGamePiece.speedY = 5; \n    }\n    if (myGameArea.keys && myGameArea.keys[32])\n    {\n    \tif(myGamePiece.boostCd)\n    \t{\n    \t\tmyGamePiece.boostCd--;\n    \t}\n    \telse if(myGamePiece.totalBoosts && (myGamePiece.speedX != 0 || myGamePiece.speedY != 0) && !myGamePiece.isBoosting)\n    \t{\n    \t\tmyGamePiece.boost();\n    \t}\n    }\n    if(myGameArea.keys && myGameArea.keys[82])\n    {\n    \tif(gameControl.isGameOver)\n    \t{\n    \t\trestartGame();\n    \t}\n    }\n    //get water area\n    waterArea.update();\n    //get sky area\n    skyArea.update();\n    //get pause button\n    if(!gameControl.isGameOver)\n    \tmyPauseButton.update();\n    //get enemies\n    for(var i = 0; i < enemies.length; i++)\n    {\n    \tif(gameControl.isGameOver && !enemies.isEnding)\n    \t\tenemies[i].endAnimation();\n    \tenemies[i].newPos();\n    \tenemies[i].update();\n    }\n\n    //get player\n    myGamePiece.newPos();   \n    myGamePiece.update();\n\n    gameControl.updateScore();\n\n    //check for collision with player, hooks and bait\n    if(!gameControl.isGameOver)\n    {\n\t    var j = 0;\n\t    for(var i = 0; i < enemies.length; i++)\n\t    {\n\t    \tif(myGamePiece.checkCollision(enemies[i]))\n\t    \t{\n\t    \t\t//bonkSfx();\n\t    \t\tgameControl.deathString = \"BONKED!\";\n\t    \t\tgameControl.isPaused = true;\n\t    \t\tgameControl.isGameOver = true;\n\t    \t\tenemies[i].hasFish = true;\n\t    \t\t//updateLocalStorage(gameControl.score);\n\t    \t\tbreak;\n\t    \t}\n\n\t    \tfor(j = 0; j < enemies[i].linesArray.length; j++)\n\t    \t{\n\t    \t\tif(myGamePiece.checkCollision(enemies[i].linesArray[j].hook))\n\t    \t\t{\n\t    \t\t\t//pause + gameover if player hits hook\n\t    \t\t\t//hookSfx();\n\t    \t\t\tgameControl.deathString = \"HOOKED!\";\n\t    \t\t\tgameControl.isPaused = true;\n\t    \t\t\tgameControl.isGameOver = true;\n\t    \t\t\tenemies[i].hasFish = true;\n\t    \t\t\t//updateLocalStorage(gameControl.score);\n\t    \t\t\tenemies[i].linesArray[j].isReeling = true;\n\t    \t\t\tmyGamePiece.hookAttached = enemies[i].linesArray[j].hook;\n\t    \t\t}\n\n\t    \t\tif(enemies[i].linesArray[j].hasBait)\n\t    \t\t{\n\t    \t\t\tif(myGamePiece.checkCollision(enemies[i].linesArray[j].lineBait))\n\t    \t\t\t{\n\t    \t\t\t\t//eatSfx();\n\t    \t\t\t\tgameControl.score += 5;\n\t    \t\t\t\tenemies[i].linesArray[j].hasBait = false;\n\t    \t\t\t\tdelete enemies[i].linesArray[j].lineBait;\n\t    \t\t\t\t//limits three boosts\n\t    \t\t\t\tif(myGamePiece.totalBoosts < 3)\n\t    \t\t\t\t\tmyGamePiece.totalBoosts++;\n\t    \t\t\t\t//add to hunger timer\n\t    \t\t\t\tmyGamePiece.hungerTimer += 240;\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    }\n\t}\n\n\tvar tempEnem;\n\t//checks if enemies are off screen, deletes if they are\n\tfor(var i = 0; i < enemies.length; i++)\n\t{\n\t\ttempEnem = enemies[i];\n\t\tif(tempEnem.isOffScreen())\n\t\t{\n\t\t\tenemies.splice(i,1);\n\t\t\ttempEnem = null;\n\t\t\ti--;\n\t\t}\n\t}\n    \n    //increments game times (if game is not paused)\n    if(!gameControl.isPaused)\n   \t{ \n   \t\tgameControl.gameTimer++;\n\t    gameControl.diffTimer++;\n\t    gameControl.enemTimer++;\n\t    if(gameControl.gameTimer % 60 == 0)\n\t    \tgameControl.score++;\n\t    myGamePiece.hungerTimer--;\n\t    if(myGamePiece.hungerTimer < 0)\n\t    {\n\t    \t//starveSfx();\n\t    \tgameControl.deathString = \"STARVED!\";\n\t    \tgameControl.isPaused = true;\n\t    \tgameControl.isGameOver = true;\n\t    \t//updateLocalStorage(gameControl.score);\n\t    \tmyGamePiece.starve();\n\t    }\n\t}\n\n    //spawns enemy based on difficulty\n    if(gameControl.enemTimer >= ((60 * 10) - (60 * (gameControl.diffMulti - 1))))\n    {\n    \tif(gameControl.diffMulti < 1)\n    \t{\n    \t\tgenerateEnemy();\n    \t\tgameControl.enemTimer = 0;\n    \t}\n    \telse if(gameControl.diffMulti < 6)\n    \t{\n    \t\tgenerateEnemy();\n    \t\tgenerateEnemy();\n    \t\tgameControl.enemTimer = 0;\n    \t}\n    \telse\n    \t{\n    \t\tgenerateEnemy();\n    \t\tgenerateEnemy();\n    \t\tgenerateEnemy();\n    \t\tgameControl.enemTimer = 0;\n    \t}\n\n    }\n    //increase difficulty every 5 seconds\n    if(gameControl.diffTimer >= ((60 * 7)))\n    {\n    \tif(gameControl.diffMulti != 9)\n    \t\tgameControl.diffMulti++;\n    \tgameControl.diffTimer = 0;\n    }\n}\n\nclass component{\n\tconstructor(width, height, images, x, y, type,isRight)\n\t{\n\t\tthis.type = type;\n\t  \tif (this.type == \"image\") {\n\t  \t\tthis.images = images;\n\t\t    this.image = new Image();\n\t\t    this.image.src = images[0];\n\t  \t}\n\t  \telse\n\t  \t{\n\t  \t\tthis.images = images;\n\t  \t}\n\t    this.gamearea = myGameArea;\n\t    this.width = width;\n\t    this.height = height;\n\t    this.speedX = 0;\n\t    this.speedY = 0;    \n\t    this.x = x;\n\t    this.y = y;    \n\t    this.isRight = isRight;\n\t    this.shouldFlipY = false;\n\t}\n\tupdate()\n\t{\n\t\tvar ctx = myGameArea.context;\n\t    if (this.type == \"image\") {\n\t    \tif(!this.isRight)\n\t    \t{\n\t    \t\tif(this.shouldFlipY)\n\t       \t\t{\n\t\t       \t\tctx.save();\n\t\t       \t\tctx.scale(-1,-1);\n\t\t       \t\tctx.drawImage(this.image,-this.x -this.width,-this.y - this.height);\n\t\t       \t\tctx.restore();\n\t       \t\t}\n\t       \t\telse\n\t       \t\t{\n\t\t    \t\tctx.save();\n\t\t\t\t\tctx.scale(-1, 1);\n\t\t\t\t\tctx.drawImage(this.image, \n\t\t\t        -this.x - this.width, \n\t\t\t        this.y,\n\t\t\t        this.width, this.height);\n\t\t\t        ctx.restore();\n\t\t    \t}\n\t    \t}\n\t    \telse\n\t    \t{\n\t    \t\tif(this.shouldFlipY)\n\t      \t\t{\n\t\t       \t\tctx.save();\n\t\t       \t\tctx.scale(1,-1);\n\t\t       \t\tctx.drawImage(this.image,this.x,-this.y - this.height);\n\t\t       \t\tctx.restore();\n\t       \t\t}\n\t       \t\telse\n\t       \t\t{\n\t\t\t\t    ctx.drawImage(this.image, \n\t\t\t        this.x, \n\t\t\t        this.y,\n\t\t\t        this.width, this.height);\n\t\t\t\t}\n\t       }\n\n  \t\t}\n  \t\t//fill in rect if no image passed\n  \t\telse{\n\t\t    ctx.fillStyle = this.images;\n\t\t    ctx.fillRect(this.x, this.y, this.width, this.height);\n\t\t}\n    }\n\n    checkCollision(otherComponent)\n\t{\n\t\t//checks if this component is within another\n\t\tif(this.x < otherComponent.x + otherComponent.width && this.x + this.width > otherComponent.x \n\t\t\t&& this.y < otherComponent.y + otherComponent.height\n\t\t\t&& this.y + this.height > otherComponent.y)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nclass player extends component\n{\n\tconstructor(width, height, images, x, y, type,isRight)\n\t{\n\t\tsuper(width,height,images,x,y,type,isRight);\n\t\tthis.playerAnimCount = 0;\n\t\tthis.curPlayerAnimIndex = 0;\n\t\tthis.hookAttached = null;\n\n\t\t//boost related variables to keep track of\n\t\tthis.totalBoosts = 3;\n\t\tthis.isBoosting = false;\n\t\tthis.boostLocation = new Array(0,0);\n\t\tthis.boostLength = 100; //length of boost in pixels\n\t\tthis.boostDuration = 5; //duration of boost in frames\n\t\tthis.boostCd = 0;\n\t\tthis.hungerTimer = 1800;//1800 = 30sec\n\t}\n\n\tupdateAnim()\n\t{\n\t\tif(this.playerAnimCount > 10)\n\t    {\n\t    \tif(this.curPlayerAnimIndex == (this.images.length - 1))\n\t    \t{\n\t    \t\tthis.image.src = this.images[0];\n\t    \t\tthis.curPlayerAnimIndex = 0;\n\t    \t}\n\t    \telse\n\t    \t{\n\t   \t\t\tthis.curPlayerAnimIndex++;\n\t    \t\tthis.image.src = this.images[this.curPlayerAnimIndex];\n\t    \t}\n\n\t    \tthis.playerAnimCount = 0;\n\t    }\n\t}\n\n\tnewPos()\n\t{\n\t\tif(!gameControl.isPaused)\n\t\t{\n\t\t\tvar borderCollisionX = false;\n\t    \tvar borderCollisionY = false;\n\n\t    \t//these variables will hold the speed of x that we are adding to player (depends on whether player is boosting or not)\n\t    \tvar tempSpeedX;\n\t    \tvar tempSpeedY;\n\n\t    \tif(this.isBoosting)\n\t    \t{\n\t\t\t\tif(this.x != this.boostLocation[0])\n\t\t\t\t{\n\t\t\t\t\tif(this.x <= this.boostLocation[0])\n\t\t\t\t\t\ttempSpeedX = this.boostLength / this.boostDuration;\n\t\t\t\t\telse\n\t\t\t\t\t\ttempSpeedX = (this.boostLength / this.boostDuration) * -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttempSpeedX = 0;\n\t\t\t\t}\n\t\t\t\tif(this.y != this.boostLocation[1])\n\t\t\t\t{\n\t\t\t\t\tif(this.y <= this.boostLocation[1])\n\t\t\t\t\t\ttempSpeedY = this.boostLength / this.boostDuration;\n\t\t\t\t\telse\n\t\t\t\t\t\ttempSpeedY = (this.boostLength / this.boostDuration) * -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttempSpeedY = 0;\n\t\t\t\t}\n\t    \t}\n\t    \telse\n\t    \t{\n\t    \t\ttempSpeedX = this.speedX;\n\t    \t\ttempSpeedY = this.speedY;\n\t    \t}\n\n\t    \tif(this.x + tempSpeedX > myGameArea.canvas.width - this.width)\n\t    \t{\n\t    \t\tthis.x = myGameArea.canvas.width - this.width;\n\t    \t\tborderCollisionX = true;\n\n\t    \t}\n\t    \tif(this.x + tempSpeedX < 0)\n\t    \t{\n\t    \t\tthis.x = 0;\n\t    \t\tborderCollisionX = true;\n\t    \t}\n\t    \tif(this.y + tempSpeedY > myGameArea.canvas.height - this.height)\n\t    \t{\n\t    \t\tthis.y = myGameArea.canvas.height - this.height;\n\t    \t\tborderCollisionY = true;\n\t    \t}\n\t    \tif(this.y + tempSpeedY < 100)\n\t    \t{\n\t    \t\tthis.y = 100;\n\t    \t\tborderCollisionY = true;\n\t    \t}\n\t    \tif(!borderCollisionX)\n\t    \t{\n\t    \t\tthis.x += tempSpeedX; \n\t    \t}    \n\t    \tif(!borderCollisionY)\n\t    \t{\n\t    \t\tthis.y += tempSpeedY;\n\t    \t\t//gravity underwater (only when not boosting)\n\t    \t\tif(!this.isBoosting && this.y != myGameArea.canvas.height + this.height)\n\t    \t\t\tthis.y += 0.5;\n\t    \t}\t\n\n\t    \tif(this.speedX != 0 || this.speedY != 0)\n\t\t    {\n\t\t    \tthis.playerAnimCount++;\n\t\t    } \n\t\t    else\n\t\t    {\n\t\t    \tthis.playerAnimCount = 0;\n\t\t    \tthis.curPlayerAnimIndex = 0;\n\t\t    \tthis.image.src = this.images[this.curPlayerAnimIndex];\t\n\t    \t}    \n\n\t    \tif(this.isBoosting)\n\t    \t{\n\t    \t\tif(this.x == this.boostLocation[0] && this.y == this.boostLocation[1])\n\t    \t\t{\n\t    \t\t\tthis.isBoosting = false;\n\t    \t\t\t//cooldown for boost - in frames\n\t    \t\t\tthis.boostCd = 5;\n\t    \t\t}\n\t    \t}\n\t    \tthis.updateAnim();   \n    \t}\n    \tif(gameControl.isGameOver)\n    \t{\n    \t\t//lost because of hook\n    \t\tif(this.hookAttached)\n    \t\t{\n    \t\t\tthis.loseAnimationHook();\n    \t\t}\n    \t\t//lost because of hunger timer\n    \t\telse if(this.hungerTimer <= 0)\n    \t\t{\n    \t\t\tif(this.y >= waterArea.y - 16)\n    \t\t\t\tthis.y -= 3;\n    \t\t}\n    \t\t//lost because of collision with enemy boat\n    \t\telse\n    \t\t{\n    \t\t\tif(this.y >= waterArea.y - 32)\n    \t\t\t\tthis.y--;\n    \t\t}\n    \t}      \n\t}\n\n\tloseAnimationHook()\n\t{\n\t\t//later I will make fish turn to face angle of line, for now I do not need this\n\t\tthis.x = this.hookAttached.x;\n\t\tthis.y = this.hookAttached.y;\n\t}\n\n\tboost()\n\t{\n\t\tif(this.speedX > 0)\n\t\t{\n\t\t\tthis.boostLocation[0] = this.x + this.boostLength;\n\t\t\tif(this.boostLocation[0] > myGameArea.canvas.width - this.width)\n\t\t\t{\n\t\t\t\tthis.boostLocation[0] = myGameArea.canvas.width - this.width;\n\t\t\t}\n\t\t}\n\t\telse if(this.speedX < 0)\n\t\t{\n\t\t\tthis.boostLocation[0] = this.x - this.boostLength;\n\t\t\tif(this.boostLocation[0] < 0)\n\t\t\t{\n\t\t\t\tthis.boostLocation[0] = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.boostLocation[0] = this.x;\n\t\t}\n\t\tif(this.speedY > 0)\n\t\t{\n\t\t\tthis.boostLocation[1] = this.y + this.boostLength;\n\t\t\tif(this.boostLocation[1] > myGameArea.canvas.height - this.height)\n\t\t\t{\n\t\t\t\tthis.boostLocation[1] = myGameArea.canvas.height - this.height;\n\t\t\t}\n\t\t}\n\t\telse if(this.speedY < 0)\n\t\t{\n\t\t\tthis.boostLocation[1] = this.y - this.boostLength;\n\t\t\tif(this.boostLocation[1] < 100)\n\t\t\t{\n\t\t\t\tthis.boostLocation[1] = 100;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.boostLocation[1] = this.y;\n\t\t}\n\n\t\t//prevents player from getting stuck in the bottom\n\t\tif(this.boostLocation[1] + this.height > myGameArea.canvas.height - this.height)\n\t\t\tthis.boostLocation[1] = myGameArea.canvas.height - this.height;\n\n\t\tif(!gameControl.isGameOver)\n\t\t\t//boostSfx();\n\t\tthis.totalBoosts--;\n\t\tthis.isBoosting = true;\n\t}\n\n\tdrawBoostCircles(ctx)\n\t{\n\t\tvar tempX;\n\t\tvar tempY;\n\t\tfor(var i = 1; i <= 3; i++)\n\t\t{\n\t\t\ttempX = this.x + ((this.width / 2) * (i - 1));\n\t\t\ttempY = this.y - 8;\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(tempX,tempY,6,0,2 * Math.PI, false);\n\t\t\t//full circle - if there is a boost, fill the circle\n\t\t\tif(i <= this.totalBoosts)\n\t\t\t{\n\t\t\t\tctx.fillStyle = 'pink';\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t\t//empty circle - no boost\n\t\t\tctx.strokeStyle = 'hotpink';\n\t\t\tctx.stroke();\n\n\t\t}\n\t}\n\n\tstarve()\n\t{\n\t\tthis.shouldFlipY = true;\n\t}\n\n\tdrawHungerTimer(ctx)\n\t{\n\t\tctx.font = \"30px Comic Sans MS\";\n\t\tif(this.hungerTimer > 300)\n\t\t\tctx.fillStyle = \"hotpink\";\n\t\telse\n\t\t\tctx.fillStyle = \"red\";\n\t\tctx.textAlign = \"center\";\n\t\tif(!this.isGameOver)\n\t\t\tctx.fillText(\"\" + Math.round(this.hungerTimer / 60), this.x + (this.width / 2), this.y - 16);\n\t}\n\n\tupdate()\n\t{\n\t\tif(!gameControl.isGameOver)\n\t\t{\n\t\t\tthis.drawHungerTimer(myGameArea.context);\n\t\t\tthis.drawBoostCircles(myGameArea.context);\n\t\t}\n\t\tsuper.update();\n\t}\n}\n\nfunction generateEnemy()\n{\n\tvar newWidth = randomIntFromInterval(32,128);\n\tvar newHeight = 32;\n\tvar spawnLoc = Math.floor((Math.random() * 2) + 1);\n\tvar newY;\n\tvar newX;\n\tvar newIsRight;\n\tif(spawnLoc == 1)\n\t{\n\t\tnewY = 100 - (newHeight / 2);\n\t\tnewX = 0 - newWidth;\n\t\tnewIsRight = true;\n\t}\n\telse\n\t{\n\t\tnewY = 100 - (newHeight / 2);\n\t\tnewX = myGameArea.canvas.width;\n\t\tnewIsRight = false;\n\t}\n\t//randomly generate speed later\n\tif(gameControl.diffMulti < 5)\n\t\tvar newSpeed = randomIntFromInterval(1,3);\n\telse\n\t\tvar newSpeed = randomIntFromInterval(2,6);\n\tvar newNumPoles;\n\tif(gameControl.diffMulti == 1)\n\t\tnewNumPoles = 1;\n\telse if(gameControl.diffMulti < 4)\n\t{\n\t\tnewNumPoles = randomIntFromInterval(1,2);\n\t}\n\telse if(gameControl.diffMulti < 7)\n\t{\n\t\tnewNumPoles = randomIntFromInterval(1,3);\n\t}\n\telse\n\t{\n\t\tnewNumPoles = randomIntFromInterval(1,4);\n\t}\n\tenemies.push(new enemy(newWidth, newHeight,[\"boat.png\"], newX, newY, \"image\", newIsRight, newSpeed, newNumPoles));\n}\n\n//enemy class\nclass enemy extends component\n{\n\t//movement function (bobs up and down and moves across)\n\t//new constructor that specifies speed\n\t//array of lines\n\t//pole draw function (hard)\n\t//number of poles\n\tconstructor(width, height, images, x, y, type, isRight, speed, numPoles)\n\t{\n\t\tsuper(width,height,images,x,y,type,isRight);\n\t\tthis.speedX = speed;\n\t\tthis.numPoles = numPoles;\n\t\tthis.linesArray = new Array();\n\t\tthis.startingPositions = new Array();\n\t\tthis.getStartingPositions();\n\t\tthis.generateLines();\n\t\tthis.hasFish = false;\n\t\tthis.isEnding = false;\n\t}\n\n\tnewPos()\n\t{\n\t\tif(!gameControl.isPaused || (gameControl.isGameOver && !this.hasFish))\n\t\t{\n\t\t\t//need to add bobbing up and down here\n\t\t\tif(this.isRight)\n\t\t\t{\n\t\t\t\tthis.x += this.speedX;\n\t\t\t\tfor(var i = 0; i < this.startingPositions.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.startingPositions[i] += this.speedX;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.x -= this.speedX;\n\t\t\t\tfor(var i = 0; i < this.startingPositions.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.startingPositions[i] -= this.speedX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tendAnimation()\n\t{\n\t\tif(!this.isEnding)\n\t\t{\n\t\t\tif(!this.hasFish)\n\t\t\t{\n\t\t\t\tthis.isEnding = true;\n\t\t\t\tif(this.x + this.width > myGameArea.canvas.width / 2)\n\t\t\t\t{\n\t\t\t\t\tthis.isRight = true;\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.isRight = false;\n\t\t\t\t}\n\t\t\t\tfor(var i = 0; i < this.linesArray.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.linesArray[i].speed *=3;\n\t\t\t\t\tif(this.linesArray[i].isRight == this.isRight)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.linesArray[i].hook.isRight = this.isRight;\n\t\t\t\t\t\tif(this.linesArray[i].hasBait)\n\t\t\t\t\t\t\tthis.linesArray[i].lineBait.isRight = this.isRight;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\n\t\t\t\t\t\tthis.linesArray[i].isRight = this.isRight;\n\t\t\t\t\t\t//this means that it will be turning right\n\t\t\t\t\t\tif(this.isRight)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.linesArray[i].startPos[0] -= 30;\n\t\t\t\t\t\t\tthis.linesArray[i].endPos[0] -= 30;\n\t\t\t\t\t\t\tthis.linesArray[i].hook.x -= 30;\n\t\t\t\t\t\t\tif(this.linesArray[i].hasBait)\n\t\t\t\t\t\t\t\tthis.linesArray[i].baitPoint[0] -= 30;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.linesArray[i].startPos[0] += 30;\n\t\t\t\t\t\t\tthis.linesArray[i].endPos[0] += 30;\n\t\t\t\t\t\t\tthis.linesArray[i].hook.x += 30;\n\t\t\t\t\t\t\tif(this.linesArray[i].hasBait)\n\t\t\t\t\t\t\t\tthis.linesArray[i].baitPoint[0] += 30;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.linesArray[i].hook.isRight = this.isRight;\n\t\t\t\t\t\tif(this.linesArray[i].hasBait)\n\t\t\t\t\t\t\tthis.linesArray[i].lineBait.isRight = this.isRight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.isEnding = true;\n\t\t\t}\n\n\t\t\tthis.speedX *= 3;\n\t\t}\n\t}\n\n\t//gets starting positions of the lines\n\tgetStartingPositions()\n\t{\n\t\t//draw each pole, starting from the left\n\t\tvar tempPos = this.x;\n\t\tfor(var i = 0; i < this.numPoles; i++)\n\t\t{\n\t\t\ttempPos = tempPos + (this.width/(this.numPoles + 1));\n\t\t\tthis.startingPositions.push(tempPos);\n\t\t}\n\t}\n\n\t//generates lines that are coming off of the boat\n\tgenerateLines()\n\t{\n\t\tvar newAngle;\n\t\tvar newLength;\n\t\tvar newHasBait;\n\t\tvar startPos;\n\t\tfor(var i = 0; i < this.startingPositions.length; i++)\n\t\t{\n\t\t\t//calculates an angle between 45 and 90 degs\t\n\t\t\tnewLength = randomIntFromInterval(75,510);\n\n\t\t\tif(gameControl.diffMulti == 1)\n\t\t\t\tnewHasBait = 1;\n\t\t\telse if(gameControl.diffMulti < 4)\n\t\t\t\tnewHasBait = randomIntFromInterval(1,2);\n\t\t\telse if(gameControl.diffMulti < 7)\n\t\t\t\tnewHasBait = randomIntFromInterval(1,3);\n\t\t\telse\n\t\t\t\tnewHasBait = randomIntFromInterval(1,5);\n\t\t\tif(newHasBait == 1)\n\t\t\t\tnewHasBait = true;\n\t\t\telse\n\t\t\t\tnewHasBait = false;\n\t\t\tif(!this.isRight)\n\t\t\t{\n\t\t\t\tstartPos = [this.startingPositions[i] + 15,this.y - 15];\n\t\t\t\tnewAngle = randomIntFromInterval(45,90);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstartPos = [this.startingPositions[i] - 15,this.y - 15];\n\t\t\t\tnewAngle = randomIntFromInterval(90,135);\n\t\t\t}\n\t\t\t\n\t\t\tthis.linesArray.push(new line(newAngle,startPos, newLength,this.speedX,this.isRight,newHasBait,this));\n\t\t}\n\t}\n\n\tdrawPoles()\n\t{\n\t\tvar ctx = myGameArea.context;\n\t\tfor(var i = 0; i < this.startingPositions.length; i++)\n\t\t{\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(this.startingPositions[i],this.y);\n\t\t\tctx.lineTo(this.startingPositions[i],this.y - 15);\n\t\t\tif(!this.isRight)\n\t\t\t{\n\t\t\t\tctx.lineTo(this.startingPositions[i] + 15,this.y - 15);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tctx.lineTo(this.startingPositions[i] - 15,this.y - 15);\n\t\t\t}\n\t\t\tctx.strokeStyle = 'black';\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\tdrawLines()\n\t{\n\t\tfor(var i = 0; i < this.linesArray.length; i++)\n\t\t{\n\t\t\tthis.linesArray[i].newPos();\n\t\t\tthis.linesArray[i].update();\n\t\t}\n\t}\n\n\tupdate()\n\t{\n\t\tsuper.update();\n\t\tthis.drawPoles();\n\t\tthis.drawLines();\n\t\t\n\t}\n\n\tisOffScreen()\n\t{\n\t\tvar tempHook;\n\t\tvar boatOffScreen = false;\n\n\t\tif(this.isRight)\n\t\t{\n\t\t\tif(this.x > myGameArea.canvas.width)\n\t\t\t{\n\t\t\t\tboatOffScreen = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(this.x + this.width < 0)\n\t\t\t{\n\t\t\t\tboatOffScreen = true;\n\t\t\t}\n\t\t}\n\n\t\t//if the boat is not off the screen, there is no reason to delete it\n\t\tif(!boatOffScreen)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tvar numHooksOff = 0;\n\t\tfor(var i = 0; i < this.linesArray.length; i++)\n\t\t{\n\t\t\ttempHook = this.linesArray[i].hook;\n\t\t\tif(this.isRight)\n\t\t\t{\n\t\t\t\tif(tempHook.x > myGameArea.canvas.width)\n\t\t\t\t{\n\t\t\t\t\tnumHooksOff++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(tempHook.x + tempHook.width < 0)\n\t\t\t\t{\n\t\t\t\t\tnumHooksOff++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//returns true if all hooks are off the screen\n\t\tif(numHooksOff == this.linesArray.length)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n//line class, not a component because not a rectangle\nclass line\n{\n\tconstructor(angle, startPos, length, speed, isRight, hasBait, parentBoat)\n\t{\n\t\tthis.angle = angle;\n\t\tthis.startPos = startPos;\n\t\tthis.length = length;\n\t\tthis.speed = speed;\n\t\tthis.isRight = isRight;\n\t\tthis.parentBoat = parentBoat;\n\t\tthis.endPos = new Array();\n\t\tthis.calculateEndPos();\n\t\tthis.hasBait = hasBait;\n\t\tif(hasBait)\n\t\t{\n\t\t\tthis.baitPoint = new Array();\n\t\t\tthis.generateBaitPoint();\n\t\t\tthis.lineBait = new bait(this.baitPoint[0],this.baitPoint[1], this);\n\t\t}\n\t\tvar xPos;\n\t\tvar yPos;\n\t\tif(this.isRight)\n\t\t{\n\t\t\txPos = this.endPos[0] + 12;\n\t\t}\n\t\telse\n\t\t{\n\t\t\txPos = this.endPos[0] - 12;\n\t\t}\n\t\tthis.hook = new hook(24,24,[\"hook.png\"],xPos,this.endPos[1],\"image\",this.isRight,this.speed,this);\n\t\tthis.isReeling = false;\n\t}\n\n\t//hitting a line will slow the player down (unless obtaining bait)\n\tcollisionCheck()\n\t{\n\n\t}\n\n\t//move the start position of the line before next update\n\tnewPos()\n\t{\n\t\tif(!gameControl.isPaused || (gameControl.isGameOver && !this.parentBoat.hasFish))\n\t\t{\n\t\t\tif(this.isRight)\n\t\t\t{\n\t\t\t\tthis.startPos[0] += this.speed;\n\t\t\t\tthis.endPos[0] += this.speed;\n\t\t\t\tif(this.hasBait)\n\t\t\t\t\tthis.baitPoint[0] += this.speed;\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.startPos[0] -= this.speed;\n\t\t\t\tthis.endPos[0] -= this.speed;\n\t\t\t\tif(this.hasBait)\n\t\t\t\t\tthis.baitPoint[0] -= this.speed;\n\t\t\t}\n\t\t}\n\t\tif(this.isReeling)\n\t\t{\n\t\t\tif(this.hasBait)\n\t\t\t{\n\t\t\t\tthis.hasBait = false;\n\t\t\t\tdelete this.lineBait;\n\t\t\t}\n\t\t\tif(this.length >= 0)\n\t\t\t{\n\t\t\t\tthis.length -= 3;\n\t\t\t\tthis.calculateEndPos();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.length = 0;\n\t\t\t\tthis.isReeling = false;\n\t\t\t}\n\n\t\t}\n\t\tthis.hook.newPos();\n\t\tif(this.hasBait)\n\t\t\tthis.lineBait.newPos();\n\t}\n\n\tcalculateEndPos()\n\t{\n\t\tthis.endPos[0] = this.startPos[0] + (this.length * Math.cos(Math.PI *this.angle / 180));\n\t\tthis.endPos[1] = this.startPos[1] + (this.length * Math.sin(Math.PI *this.angle / 180));\n\t}\n\n\t//draw line\n\tupdate()\n\t{\n\t\t//draw the line\n\t\tvar ctx = myGameArea.context;\n\t\tctx.beginPath();\n\t\tctx.moveTo(this.startPos[0],this.startPos[1]);\n\t\tctx.lineTo(this.endPos[0],this.endPos[1]);\n\t\tctx.strokeStyle = 'black';\n\t\tctx.stroke();\n\t\t//draw the hook\n\t\tthis.hook.update();\n\t\tif(this.hasBait)\n\t\t\tthis.lineBait.update();\n\t}\n\n\t//moveline - later when I add up and down movement to line\n\tmoveLine()\n\t{\n\n\t}\n\t//will be used to generate a point to put the bait on the line\n\tgenerateBaitPoint()\n\t{\n\t\t//bait will be randomly placed from halfway down the line to the end\n\t\tvar baitLength = randomIntFromInterval((this.length / 2), this.length - 10);\n\n\t\t//get x position of bait\n\t\tthis.baitPoint[0] =  this.startPos[0] + (baitLength * Math.cos(Math.PI *this.angle / 180));\n\t\t//get y position of bait\n\t\tthis.baitPoint[1] = this.startPos[1] + (baitLength * Math.sin(Math.PI *this.angle / 180));\n\t}\n}\n\n//bait class, feeds player, gives boost, and increases score by 5\nclass bait extends component\n{\n\tconstructor(x,y, parentLine)\n\t{\n\t\tsuper(24,24, [\"bait1.png\",\"bait2.png\"], x, y, \"image\", parentLine.isRight);\n\t\tthis.parentLine = parentLine;\n\t\tthis.animCount = 0;\n\t\tthis.curAnimIndex = 0;\n\t\tthis.animLength = randomIntFromInterval(10,20);\n\t}\n\n\tupdateAnim()\n\t{\n\t\tif(this.animCount > this.animLength)\n\t    {\n\t    \tif(this.curAnimIndex == (this.images.length - 1))\n\t    \t{\n\t    \t\tthis.image.src = this.images[0];\n\t    \t\tthis.curAnimIndex = 0;\n\t    \t}\n\t    \telse\n\t    \t{\n\t   \t\t\tthis.curAnimIndex++;\n\t    \t\tthis.image.src = this.images[this.curAnimIndex];\n\t    \t}\n\n\t    \tthis.animCount = 0;\n\t    }\n\t}\n\n\tnewPos()\n\t{\n\n\t\tthis.x = this.parentLine.baitPoint[0] - 12;\n\t\tthis.y = this.parentLine.baitPoint[1];\n\t\tif(!gameControl.isPaused || (gameControl.isGameOver && !this.parentLine.parentBoat.hasFish))\n\t\t{\n\t\t\tthis.animCount++;\n\t\t\tthis.updateAnim();\t\n\t\t}\n\t}\n}\n\n//hook class\nclass hook extends component\n{\t\n\tconstructor(width, height, images, x, y, type, isRight, speed, parentLine)\n\t{\n\t\tsuper(width, height, images, x, y, type, isRight);\n\t\tif(isRight)\n\t\t{\n\t\t\tthis.x = this.x - this.width;\n\t\t}\n\t\tthis.speedX = speed;\n\t\tthis.parentLine = parentLine;\n\t}\n\n\t//making it so the hook is always on the end of the line, no matter where it moves to\n\tnewPos()\n\t{\n\n\t\tthis.x = this.parentLine.endPos[0] - 12;\n\t\tthis.y = this.parentLine.endPos[1];\t\n\t}\n\n\tupdate()\n\t{\n\t\tsuper.update();\n\t}\n}\n\n//graphic for a pause button\nclass pauseButton\n{\n\tconstructor(x,y,width,height)\n\t{\n\t\t//initially the game will start off playing\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.playing = true;\n\t}\n\n\tupdate()\n\t{\n\t\tif(gameControl.isPaused)\n\t\t\tthis.playing = false;\n\t\telse\n\t\t\tthis.playing = true;\n\n\t\tvar ctx = myGameArea.context;\n\t\tctx.fillStyle = \"black\";\n\n\t\t//draws pause icon\n\t\tif(this.playing)\n\t\t{\t\n\t\t\tctx.fillRect(this.x, this.y, this.width / 3, this.height);\n\t\t\tctx.fillRect(this.x + 2 * (this.width / 3), this.y, this.width / 3, this.height);\n\t\t}\n\t\t//draws play icon\n\t\telse\n\t\t{\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(this.x,this.y);\n\t\t\tctx.lineTo(this.x, this.y + this.height);\n\t\t\tctx.lineTo(this.x + this.width, this.y + (this.height / 2));\n\t\t\tctx.fill();\n\t\t}\n\t}\n}\n\n//HELPER FUNCTIONS BELOW\nfunction randomIntFromInterval(min,max)\n{\n    return Math.floor(Math.random()*(max-min+1)+min);\n}\n\n//mouse detection functions (only used for pause button)\nfunction getMousePos(canvas, event) {\n\tvar rect = myGameArea.canvas.getBoundingClientRect();\n\treturn {\n\t\tx: event.clientX - rect.left,\n\t\ty: event.clientY - rect.top\n\t};\n}\nfunction isInside(pos, rect){\n\treturn pos.x > rect.x && pos.x < rect.x+rect.width && pos.y < rect.y+rect.height && pos.y > rect.y;\n}\n\n//displays game over text in middle of screen\nfunction gameOverText(text)\n{\n\tvar ctx = myGameArea.context;\n\tctx.font = \"50px Comic Sans MS\";\n\tctx.fillStyle = \"black\";\n\tctx.textAlign = \"center\";\n\tctx.fillText(\"\" + text, 400, 300);\n}\n\n//sound effects - made with miniMusic - https://xem.github.io/miniMusic/simple.html\n/*\nfunction boostSfx()\n{\n\twith(new AudioContext)\n\twith(G=createGain())\n\tfor(i in D=[14,9,2])\n\twith(createOscillator())\n\tif(D[i])\n\tconnect(G),\n\tG.connect(destination),\n\tstart(i*.05),\n\tfrequency.setValueAtTime(440*1.06**(13-D[i]),i*.05),type='triangle',\n\tgain.setValueAtTime(1,i*.05),\n\tgain.setTargetAtTime(.0001,i*.05+.03,.005),\n\tstop(i*.05+.04);\n}\n\nfunction eatSfx()\n{\n\twith(new AudioContext)\n\twith(G=createGain())\n\tfor(i in D=[14,12,12,9])\n\twith(createOscillator())\n\tif(D[i])\n\tconnect(G),\n\tG.connect(destination),\n\tstart(i*.075),\n\tfrequency.setValueAtTime(440*1.06**(13-D[i]),i*.075),type='triangle',\n\tgain.setValueAtTime(1,i*.075),\n\tgain.setTargetAtTime(.0001,i*.075+.05,.005),\n\tstop(i*.075+.07);\n}\n\nfunction hookSfx()\n{\n\twith(new AudioContext)\n\twith(G=createGain())\n\tfor(i in D=[18,19,24,25,24])\n\twith(createOscillator())\n\tif(D[i])\n\tconnect(G),\n\tG.connect(destination),\n\tstart(i*.1),\n\tfrequency.setValueAtTime(440*1.06**(13-D[i]),i*.1),type='triangle',\n\tgain.setValueAtTime(1,i*.1),\n\tgain.setTargetAtTime(.0001,i*.1+.08,.005),\n\tstop(i*.1+.09);\n}\n\nfunction bonkSfx()\n{\n\twith(new AudioContext)\n\twith(G=createGain())\n\tfor(i in D=[22,22,23,24,23])\n\twith(createOscillator())\n\tif(D[i])\n\tconnect(G),\n\tG.connect(destination),\n\tstart(i*.022),\n\tfrequency.setValueAtTime(440*1.06**(13-D[i]),i*.022),\n\tgain.setValueAtTime(1,i*.022),\n\tgain.setTargetAtTime(.0001,i*.022+.00,.005),\n\tstop(i*.022+.01);\n}\n\nfunction starveSfx()\n{\n\twith(new AudioContext)\n\twith(G=createGain())\n\tfor(i in D=[21,,24,24,25])\n\twith(createOscillator())\n\tif(D[i])\n\tconnect(G),\n\tG.connect(destination),\n\tstart(i*.22),\n\tfrequency.setValueAtTime(440*1.06**(13-D[i]),i*.22),\n\tgain.setValueAtTime(1,i*.22),\n\tgain.setTargetAtTime(.0001,i*.22+.20,.005),\n\tstop(i*.22+.21)\n}\n*/\n\n\n"]},"metadata":{},"sourceType":"module"}